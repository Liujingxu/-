# 稀疏矩阵
![sparse](./sparse.png)
## 二维数组转稀疏数组的思路
1. 遍历原始二维数组，得到有效的数据的个数
2. 根据sum就可以创建稀疏数组
3. 将二维数组的有效数据存入稀疏数组

## 稀疏数组转二维数组
1. 读取第一行，创建二维数组
2. 再读取后几行，填入数据 


# 队列
## 直队列
 - 队列是一个有序列表，可以用数组或是链表来实现。
 - 遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出
 - 示意图：(使用数组模拟队列示意图)
   ![队列1](./que1.png)
 
 ### 模拟
 1. 队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。
 
 2. 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变
 3. 当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：
    **思路分析**: 
    - 将尾指针往后移：rear+1 , 当front == rear 【空】
    - 若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear  == maxSize - 1[队列满]

 ### menu
 - 出队列操作getQueue
 - 显示队列的情况showQueue
 - 查看队列头元素headQueue
 - 退出系统exit
## 循环列表
 - 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满] 
 - rear == front [空]
 - 测试示意图:
 ![que2](./que2.png)

# 链表
 - 链表是以节点的方式来存储,是链式存储
 - 每个节点包含 data 域， next 域：指向下一个节点.
 - 如图：发现链表的各个节点不一定是连续存储.
 - 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定
 ![linklist](./linklist.png)
 
## 模拟
 1. 创建
 2. 添加元素
 3. 按顺序添加
 4. 删除
 5. 修改

## moron面试题
 1. 求单链表中有效节点的个数
 2. 查找单链表中的倒数第k个结点 【新浪面试题】
   **思路**
   倒数第k个节点为 正数 size - k个节点
 3. 单链表的反转【腾讯面试题，有点难度】
   **思路**: 
     1. 先定义一个节点 reverseHead = new HeroNode();
     2. 从头到尾遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端.
     3. 原来的链表的head.next = reverseHead.next
     4. 类似头插法

 4. 从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】
   **思路**
   使用stack集合存放node
   出栈输出
 5. 合并两个有序的单链表，合并之后的链表依然有序【课后练习.】
 
 ## 双向链表
 管理单向链表的缺点分析: 
 - 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
 - 单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).
 - 示意图帮助理解删除 
 ![doublelink](./doublelink.png)
 ### 模拟
 双向链表的遍历，添加，修改，删除的操作思路
 1. 遍历 方和 单链表一样，只是可以向前，也可以向后查找
 2. 添加 (默认添加到双向链表的最后)
    - 先找到双向链表的最后这个节点
    - temp.next = newHeroNode
    - newHeroNode.pre = temp;
 3. 修改 思路和 原来的单向链表一样.
 4. 删除
    - 因为是双向链表，因此，我们可以实现自我删除某个节点
    - 直接找到要删除的这个节点，比如temp
    - temp.pre.next = temp.next
    - temp.next.pre = temp.pre;
  ## 循环链表
   ### 模拟
   - 构建一个单向的环形链表思路
     - 先创建第一个节点, 让 first 指向该节点，并形成环形
     - 后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.
   
   - 遍历环形链表
     - 先让一个辅助指针(变量) curBoy，指向first节点
     - 然后通过一个while循环遍历 该环形链表即可 curBoy.next  == first 结束

   ### 约瑟夫问题
    Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1<=k<=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。
    n = 5 , 即有5个人 
    k = 1, 从第一个人开始报数
    m = 2, 数2下
   
   思路
   1.  需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.
   补充： 小孩报数前，先让 first 和  helper 移动 k - 1次
   2.  当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次
   3.  这时就可以将first 指向的小孩节点 出圈
   first = first .next 
   helper.next = first  
   原来first 指向的节点就没有任何引用，就会被回收
   
   出圈的顺序
   2->4->1->5->3
   
   ![出圈](./出圈.png)
   
# 栈
## 模拟
 - 栈的英文为(stack)
 - 栈是一个先入后出(FILO-First In Last Out)的有序列表。
 - 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
 - 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除
 
## 应用场景
 - 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 	
 - 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
 - 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
 - 二叉树的遍历。
 - 图形的深度优先(depth一first)搜索法
 
 ## 栈实现计算器
  使用栈完成表达式的计算 思路
1. 通过一个 index  值（索引），来遍历我们的表达式
2. 如果我们发现是一个数字, 将数字存入realNum字符串中，判断下一个是否是操作符：
    1. 是操作符则将realNum转为数字后入数栈
    2. 不是操作符则继续循环
3. 如果发现扫描到是一个符号,  就分如下情况
   1. 如果发现当前的符号栈为 空，就直接入栈
   2. 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.
4. 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.
5. 最后在数栈只有一个数字，就是表达式的结果

## 前缀表达式
   前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前
   > (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6
   
   从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果
   
 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:
 
 1. 从右至左扫描，将6、5、4、3压入堆栈
 2. 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
 3. 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
 4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
 

## 中缀表达式
中缀表达式就是常见的运算表达式，如(3+4)×5-6
中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)



## 后缀表达式
后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后
![](./last1.png)

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

1. 从左至右扫描，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果	

### 后缀表达式

1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2. 从左至右扫描中缀表达式；
3. 遇到操作数时，将其压s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
   1. 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
   2. 否则，若优先级比栈顶运算符的高，也将运算符压入s1；
   3. 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；
5. 遇到括号时：
    1. 如果是左括号“(”，则直接压入s1
    2. 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

# 递归
## 解决的问题
  - 各种数学问题如: 8皇后问题 , 汉诺塔, 阶乘问题, 迷宫问题, 球和篮子的问题(google编程大赛)
  - 各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等.
  - 将用栈解决的问题-->第归代码比较简洁

## 重要规则
- 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
- 方法的局部变量是独立的，不会相互影响, 比如n变量
- 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.
- 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)
- 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

## 内部实现
![jvm](./jvm.png)

## 迷宫问题
## 8皇后问题

# 排序
排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。
排序的分类：
1) 内部排序:
指将需要处理的所有数据都加载到内部存储器中进行排序。
2) 外部排序法：
数据量过大，无法全部加载到内存中，需要借助外部存储进行
排序。
3) 常见的排序算法分类:
![排序](./图片1.png)

## 度量一个程序(算法)执行时间的两种方法
   
   1. 事后统计的方法：这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。
   2. 事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优.
   
## 计算时间复杂度
   - 忽略常数项
   - 忽略低次项
   - 忽略系数   
   ![8排序](./图片2.png)

## 冒泡排序(BubbleSort)
冒泡排序（Bubble Sorting）的基本思想是：通过对待
排序序列从前向后（从下标较小的元素开始）,依次比较
相邻元素的值，若发现逆序则交换，使值较大
的元素逐渐从前移向后部，就象水底下的气泡一样逐渐
向上冒。

因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下
来没有进行过交换，就说明序列有序，因此要在排序过程中设置
一个标志flag判断元素是否进行过交换。从而减少不必要的比较。(这里说的优化，可以在冒泡排序写好后，在进行)

排序过程:
![](./bbs.png)

## 选择排序(SelectSort)
选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

排序过程：
 ![](./图片3.jpg)
 
## 插入排序(InsertSort)
插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。
排序过程：
![](./图片1.jpg)

## 希尔排序（HillSort）
希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。

希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止





